// src/settlement/settlement.service.ts - UPDATED WITH DTO TYPES
import { Injectable, Logger } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Settlement, SettlementDocument, SettlementStatus } from './settlement.schema';
import { Group, GroupDocument } from '../group/group.schema';
import {
  CreateSettlementDto,
  UpdateSettlementStatusDto,
  SettlementResponseDto,
  BalanceResponseDto,
  SettlementOptimizationResultDto,
  SettlementStatisticsDto
} from './settlement.dto';
import {
  SettlementNotFoundError,
  SettlementValidationError,
  InsufficientBalanceError,
  SettlementSameUserError,
} from './settlement.error';
import { GroupNotFoundError } from '../group/group.error';

@Injectable()
export class SettlementService {
  private readonly _logger = new Logger(SettlementService.name);

  constructor(
    @InjectModel(Settlement.name) private readonly settlementModel: Model<SettlementDocument>,
    @InjectModel(Group.name) private readonly groupModel: Model<GroupDocument>,
  ) {}

  /**
   * Create a new settlement
   */
  async createSettlement(
    groupId: string,
    createDto: CreateSettlementDto,
    createdByUserId: string,
  ): Promise<SettlementResponseDto> {
    // Validate group exists and user is member
    const group = await this.groupModel.findOne({
      _id: groupId,
      isActive: true,
    });

    if (!group) {
      throw new GroupNotFoundError(groupId);
    }

    // Validate users are group members
    const isFromUserMember = group.members.some(m => 
      m.userId.toString() === createDto.fromUserId
    );
    const isToUserMember = group.members.some(m => 
      m.userId.toString() === createDto.toUserId
    );
    
    if (!isFromUserMember || !isToUserMember) {
      throw new SettlementValidationError('Both users must be group members');
    }

    // Validate not settling with self
    if (createDto.fromUserId === createDto.toUserId) {
      throw new SettlementSameUserError();
    }

    // Validate amount
    if (createDto.amount <= 0) {
      throw new SettlementValidationError('Amount must be greater than 0');
    }

    // Check balance before creating settlement
    const balances = await this.calculateBalances(groupId);
    const fromUserBalance = balances.find(b => b.userId === createDto.fromUserId);
    
    if (!fromUserBalance || fromUserBalance.amount >= 0) {
      throw new InsufficientBalanceError(createDto.fromUserId);
    }

    // Check if amount exceeds owed amount
    const owedAmount = Math.abs(fromUserBalance.amount);
    if (createDto.amount > owedAmount) {
      throw new SettlementValidationError(
        `Amount exceeds owed amount. Maximum settlement: ${owedAmount}`
      );
    }

    // Create settlement
    const settlement = await this.settlementModel.create({
      groupId: new Types.ObjectId(groupId),
      fromUserId: new Types.ObjectId(createDto.fromUserId),
      toUserId: new Types.ObjectId(createDto.toUserId),
      amount: createDto.amount,
      date: createDto.date,
      description: createDto.description,
      paymentMethod: createDto.paymentMethod,
      transactionId: createDto.transactionId,
      isAutoGenerated: createDto.isAutoGenerated || false,
      status: SettlementStatus.PENDING,
    });

    this._logger.log(`Settlement created: ${settlement._id}`, {
      groupId,
      fromUserId: createDto.fromUserId,
      toUserId: createDto.toUserId,
      amount: createDto.amount,
    });

    return this.mapToResponseDto(settlement);
  }

  /**
   * Get all settlements for a group
   */
  async getGroupSettlements(
    groupId: string,
    filters?: {
      status?: SettlementStatus;
      fromDate?: Date;
      toDate?: Date;
      userId?: string;
      isAutoGenerated?: boolean;
    },
  ): Promise<SettlementResponseDto[]> {
    const query: any = { groupId: new Types.ObjectId(groupId) };

    if (filters?.status) {
      query.status = filters.status;
    }

    if (filters?.fromDate) {
      query.date = { $gte: filters.fromDate };
    }

    if (filters?.toDate) {
      query.date = { ...query.date, $lte: filters.toDate };
    }

    if (filters?.userId) {
      const userId = new Types.ObjectId(filters.userId);
      query.$or = [
        { fromUserId: userId },
        { toUserId: userId },
      ];
    }

    if (filters?.isAutoGenerated !== undefined) {
      query.isAutoGenerated = filters.isAutoGenerated;
    }

    const settlements = await this.settlementModel
      .find(query)
      .populate('fromUserId', 'name email')
      .populate('toUserId', 'name email')
      .sort({ date: -1, createdAt: -1 });

    return settlements.map(settlement => this.mapToResponseDto(settlement));
  }

  /**
   * Get settlement by ID
   */
  async getSettlementById(settlementId: string): Promise<SettlementResponseDto> {
    const settlement = await this.settlementModel
      .findById(settlementId)
      .populate('fromUserId', 'name email')
      .populate('toUserId', 'name email');

    if (!settlement) {
      throw new SettlementNotFoundError(settlementId);
    }

    return this.mapToResponseDto(settlement);
  }

  /**
   * Update settlement status
   */
  async updateSettlementStatus(
    settlementId: string,
    updateDto: UpdateSettlementStatusDto,
  ): Promise<SettlementResponseDto> {
    const settlement = await this.settlementModel.findById(settlementId);

    if (!settlement) {
      throw new SettlementNotFoundError(settlementId);
    }

    // Validate status transition
    this.validateStatusTransition(settlement.status, updateDto.status as SettlementStatus);

    settlement.status = updateDto.status as SettlementStatus;
    await settlement.save();

    const updatedSettlement = await this.settlementModel
      .findById(settlementId)
      .populate('fromUserId', 'name email')
      .populate('toUserId', 'name email');

    if (!updatedSettlement) {
      throw new SettlementNotFoundError(settlementId);
    }

    this._logger.log(`Settlement status updated: ${settlementId} -> ${updateDto.status}`);

    return this.mapToResponseDto(updatedSettlement);
  }

  /**
   * Delete a settlement
   */
  async deleteSettlement(settlementId: string): Promise<void> {
    const settlement = await this.settlementModel.findById(settlementId);

    if (!settlement) {
      throw new SettlementNotFoundError(settlementId);
    }

    // Only allow deletion of pending settlements
    if (settlement.status !== SettlementStatus.PENDING) {
      throw new SettlementValidationError(
        'Only pending settlements can be deleted'
      );
    }

    await this.settlementModel.deleteOne({ _id: settlementId });

    this._logger.log(`Settlement deleted: ${settlementId}`);
  }

  /**
   * Calculate balances for all group members
   */
  async calculateBalances(groupId: string): Promise<BalanceResponseDto[]> {
    const group = await this.groupModel
      .findById(groupId)
      .populate('members.userId', 'name email');

    if (!group) {
      throw new GroupNotFoundError(groupId);
    }

    const balances: BalanceResponseDto[] = [];

    // Initialize all members with zero balance
    for (const member of group.members) {
      balances.push({
        userId: member.userId['_id'].toString(),
        userName: member.userId['name'] || 'Unknown',
        amount: 0,
        paidAmount: 0,
        owedAmount: 0,
        currency: group.settings?.currency || 'INR',
      });
    }

    // Calculate based on completed settlements
    const settlements = await this.settlementModel.find({
      groupId: new Types.ObjectId(groupId),
      status: SettlementStatus.COMPLETED,
    });

    for (const settlement of settlements) {
      // Deduct from payer
      const fromBalance = balances.find(b => 
        b.userId === settlement.fromUserId.toString()
      );
      if (fromBalance) {
        fromBalance.amount -= settlement.amount;
        fromBalance.owedAmount += settlement.amount;
      }

      // Add to receiver
      const toBalance = balances.find(b => 
        b.userId === settlement.toUserId.toString()
      );
      if (toBalance) {
        toBalance.amount += settlement.amount;
        toBalance.paidAmount += settlement.amount;
      }
    }

    return balances.sort((a, b) => b.amount - a.amount);
  }

  /**
   * Optimize settlements with minimum transactions
   */
  async optimizeSettlements(groupId: string): Promise<SettlementOptimizationResultDto[]> {
    const balances = await this.calculateBalances(groupId);
    
    // Separate creditors (positive balance) and debtors (negative balance)
    const creditors = balances.filter(b => b.amount > 0.01);
    const debtors = balances.filter(b => b.amount < -0.01).map(d => ({
      ...d,
      amount: Math.abs(d.amount) // Convert to positive for calculation
    }));

    const settlements: SettlementOptimizationResultDto[] = [];
    let creditorIndex = 0;
    let debtorIndex = 0;

    while (creditorIndex < creditors.length && debtorIndex < debtors.length) {
      const creditor = creditors[creditorIndex];
      const debtor = debtors[debtorIndex];

      const settlementAmount = Math.min(creditor.amount, debtor.amount);

      settlements.push({
        fromUserId: debtor.userId,
        fromUserName: debtor.userName,
        toUserId: creditor.userId,
        toUserName: creditor.userName,
        amount: Number(settlementAmount.toFixed(2)),
      });

      // Update remaining amounts
      creditor.amount -= settlementAmount;
      debtor.amount -= settlementAmount;

      // Move to next creditor/debtor if settled
      if (Math.abs(creditor.amount) < 0.01) {
        creditorIndex++;
      }
      if (Math.abs(debtor.amount) < 0.01) {
        debtorIndex++;
      }
    }

    // Filter out zero amount settlements
    return settlements.filter(s => s.amount > 0.01);
  }

  /**
   * Create optimized settlements automatically
   */
  async createOptimizedSettlements(
    groupId: string, 
    createdByUserId: string,
    maxSettlements?: number,
  ): Promise<SettlementResponseDto[]> {
    const optimized = await this.optimizeSettlements(groupId);
    
    // Limit number of settlements if specified
    const settlementsToCreate = maxSettlements 
      ? optimized.slice(0, maxSettlements)
      : optimized;

    const createdSettlements: SettlementResponseDto[] = [];

    for (const settlement of settlementsToCreate) {
      const createDto: CreateSettlementDto = {
        fromUserId: settlement.fromUserId,
        toUserId: settlement.toUserId,
        amount: settlement.amount,
        date: new Date(),
        description: 'Automated optimized settlement',
        isAutoGenerated: true,
      };

      try {
        const created = await this.createSettlement(groupId, createDto, createdByUserId);
        createdSettlements.push(created);
      } catch (error) {
        this._logger.error(`Failed to create optimized settlement: ${error.message}`, error.stack);
      }
    }

    return createdSettlements;
  }

  /**
   * Get settlement statistics for a group
   */
  async getSettlementStatistics(groupId: string): Promise<SettlementStatisticsDto> {
    const [settlements, balances] = await Promise.all([
      this.getGroupSettlements(groupId),
      this.calculateBalances(groupId),
    ]);

    const completedSettlements = settlements.filter(s => s.status === SettlementStatus.COMPLETED);
    const totalAmount = completedSettlements.reduce((sum, s) => sum + s.amount, 0);

    const pendingCount = settlements.filter(s => s.status === SettlementStatus.PENDING).length;
    const completedCount = completedSettlements.length;
    const cancelledCount = settlements.filter(s => s.status === SettlementStatus.CANCELLED).length;

    // Calculate total debt
    const totalDebt = balances
      .filter(b => b.amount < 0)
      .reduce((sum, b) => sum + Math.abs(b.amount), 0);

    // Get recent settlements (last 5)
    const recentSettlements = settlements.slice(0, 5);

    return {
      totalSettlements: settlements.length,
      totalAmount,
      totalDebt,
      pendingCount,
      completedCount,
      cancelledCount,
      recentSettlements,
      balances,
    };
  }

  /**
   * Validate status transition
   */
  private validateStatusTransition(currentStatus: SettlementStatus, newStatus: SettlementStatus): void {
    const validTransitions: Record<SettlementStatus, SettlementStatus[]> = {
      [SettlementStatus.PENDING]: [SettlementStatus.COMPLETED, SettlementStatus.CANCELLED],
      [SettlementStatus.COMPLETED]: [SettlementStatus.CANCELLED],
      [SettlementStatus.CANCELLED]: [],
    };

    if (!validTransitions[currentStatus]?.includes(newStatus)) {
      throw new SettlementValidationError(
        `Invalid status transition from ${currentStatus} to ${newStatus}`
      );
    }
  }

  /**
   * Map entity to response DTO
   */
  private mapToResponseDto(settlement: SettlementDocument): SettlementResponseDto {
    return {
      id: settlement._id.toString(),
      groupId: settlement.groupId.toString(),
      fromUserId: settlement.fromUserId['_id']?.toString() || settlement.fromUserId.toString(),
      fromUserName: settlement.fromUserId['name'] || 'Unknown',
      toUserId: settlement.toUserId['_id']?.toString() || settlement.toUserId.toString(),
      toUserName: settlement.toUserId['name'] || 'Unknown',
      amount: settlement.amount,
      date: settlement.date,
      status: settlement.status,
      description: settlement.description,
      paymentMethod: settlement.paymentMethod,
      transactionId: settlement.transactionId,
      isAutoGenerated: settlement.isAutoGenerated || false,
      createdAt: settlement.createdAt,
      updatedAt: settlement.updatedAt,
    };
  }
}