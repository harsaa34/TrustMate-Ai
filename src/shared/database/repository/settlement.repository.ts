// src/shared/database/repository/settlement.repository.ts
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types, FilterQuery } from 'mongoose';
import { Settlement, SettlementDocument, SettlementStatus } from '../../../settlement/settlement.schema';
import { SettlementDomain } from '../../../settlement/settlement.domain';
import { SettlementMapper } from '../mapper/settlement.mapper';
import { 
  SettlementNotFoundError,
  SettlementValidationError 
} from '../../../settlement/settlement.error';
import { Group, GroupDocument } from '../../../group/group.schema';

export interface ISettlementRepository {
  // CRUD Operations
  create(settlement: SettlementDomain): Promise<SettlementDomain>;
  findById(id: string): Promise<SettlementDomain | null>;
  findAll(
    groupId: string,
    filters?: {
      status?: string;
      fromDate?: Date;
      toDate?: Date;
      userId?: string;
      isAutoGenerated?: boolean;
    },
  ): Promise<SettlementDomain[]>;
  update(id: string, settlement: SettlementDomain): Promise<SettlementDomain>;
  updateStatus(id: string, status: string): Promise<SettlementDomain>;
  delete(id: string): Promise<void>;
  
  // Business Operations
  calculateBalances(groupId: string): Promise<Array<{
    userId: string;
    userName: string;
    amount: number;
    paidAmount: number;
    owedAmount: number;
  }>>;
  
  existsById(id: string): Promise<boolean>;
  findPendingSettlementsByUser(groupId: string, userId: string): Promise<SettlementDomain[]>;
}

@Injectable()
export class SettlementRepository implements ISettlementRepository {
  constructor(
    @InjectModel(Settlement.name) private settlementModel: Model<SettlementDocument>,
    @InjectModel(Group.name) private groupModel: Model<GroupDocument>,
  ) {}

  /**
   * Create a new settlement
   */
  async create(settlement: SettlementDomain): Promise<SettlementDomain> {
    this.validateSettlement(settlement);

    const settlementData = SettlementMapper.toEntity(settlement);
    const createdSettlement = await this.settlementModel.create(settlementData);
    
    // Populate references
    const populated = await this.settlementModel
      .findById(createdSettlement._id)
      .populate('fromUserId', 'name email')
      .populate('toUserId', 'name email')
      .exec();

    const domain = SettlementMapper.toDomain(populated!);
    if (!domain) {
      throw new Error('Failed to create settlement domain');
    }
    return domain;
  }

  /**
   * Find settlement by ID
   */
  async findById(id: string): Promise<SettlementDomain | null> {
    const settlement = await this.settlementModel
      .findById(id)
      .populate('fromUserId', 'name email')
      .populate('toUserId', 'name email')
      .exec();

    if (!settlement) {
      throw new SettlementNotFoundError(id);
    }

    return SettlementMapper.toDomain(settlement);
  }

  /**
   * Find all settlements with filters
   */
  async findAll(
    groupId: string,
    filters?: {
      status?: string;
      fromDate?: Date;
      toDate?: Date;
      userId?: string;
      isAutoGenerated?: boolean;
    },
  ): Promise<SettlementDomain[]> {
    const query: FilterQuery<SettlementDocument> = {
      groupId: new Types.ObjectId(groupId),
    };

    if (filters?.status) {
      query.status = filters.status as SettlementStatus;
    }

    if (filters?.fromDate) {
      query.date = { $gte: filters.fromDate };
    }

    if (filters?.toDate) {
      query.date = { ...query.date, $lte: filters.toDate };
    }

    if (filters?.userId) {
      const userId = new Types.ObjectId(filters.userId);
      query.$or = [
        { fromUserId: userId },
        { toUserId: userId },
      ];
    }

    if (filters?.isAutoGenerated !== undefined) {
      query.isAutoGenerated = filters.isAutoGenerated;
    }

    const settlements = await this.settlementModel
      .find(query)
      .populate('fromUserId', 'name email')
      .populate('toUserId', 'name email')
      .sort({ date: -1, createdAt: -1 })
      .exec();

    return settlements
      .map(settlement => SettlementMapper.toDomain(settlement))
      .filter(Boolean) as SettlementDomain[];
  }

  /**
   * Update a settlement
   */
  async update(id: string, settlement: SettlementDomain): Promise<SettlementDomain> {
    const existing = await this.findById(id);
    if (!existing) {
      throw new SettlementNotFoundError(id);
    }

    this.validateSettlement(settlement);

    const updateData = SettlementMapper.toEntity(settlement);
    const updatedSettlement = await this.settlementModel
      .findByIdAndUpdate(id, updateData, { new: true })
      .populate('fromUserId', 'name email')
      .populate('toUserId', 'name email')
      .exec();

    if (!updatedSettlement) {
      throw new SettlementNotFoundError(id);
    }

    const domain = SettlementMapper.toDomain(updatedSettlement);
    if (!domain) {
      throw new Error('Failed to update settlement domain');
    }
    return domain;
  }

  /**
   * Update settlement status
   */
  async updateStatus(id: string, status: string): Promise<SettlementDomain> {
    const settlement = await this.settlementModel.findById(id);
    if (!settlement) {
      throw new SettlementNotFoundError(id);
    }

    this.validateStatusTransition(settlement.status, status as SettlementStatus);

    settlement.status = status as SettlementStatus;
    await settlement.save();

    const updatedSettlement = await this.settlementModel
      .findById(id)
      .populate('fromUserId', 'name email')
      .populate('toUserId', 'name email')
      .exec();

    if (!updatedSettlement) {
      throw new SettlementNotFoundError(id);
    }

    const domain = SettlementMapper.toDomain(updatedSettlement);
    if (!domain) {
      throw new Error('Failed to update settlement status');
    }
    return domain;
  }

  /**
   * Delete a settlement
   */
  async delete(id: string): Promise<void> {
    const settlement = await this.settlementModel.findById(id);
    if (!settlement) {
      throw new SettlementNotFoundError(id);
    }

    // Only allow deletion of pending settlements
    if (settlement.status !== SettlementStatus.PENDING) {
      throw new SettlementValidationError('Only pending settlements can be deleted');
    }

    const result = await this.settlementModel.deleteOne({ _id: id });
    if (result.deletedCount === 0) {
      throw new SettlementNotFoundError(id);
    }
  }

  /**
   * Calculate balances for all group members
   */
  async calculateBalances(groupId: string): Promise<Array<{
    userId: string;
    userName: string;
    amount: number;
    paidAmount: number;
    owedAmount: number;
  }>> {
    const group = await this.groupModel
      .findById(groupId)
      .populate('members.userId', 'name email');

    if (!group) {
      throw new Error(`Group with ID ${groupId} not found`);
    }

    const balances: Array<{
      userId: string;
      userName: string;
      amount: number;
      paidAmount: number;
      owedAmount: number;
    }> = [];

    // Initialize all members with zero balance
    for (const member of group.members) {
      balances.push({
        userId: member.userId['_id'].toString(),
        userName: member.userId['name'] || 'Unknown',
        amount: 0,
        paidAmount: 0,
        owedAmount: 0,
      });
    }

    // Calculate based on completed settlements
    const settlements = await this.settlementModel.find({
      groupId: new Types.ObjectId(groupId),
      status: SettlementStatus.COMPLETED,
    });

    for (const settlement of settlements) {
      // Deduct from payer
      const fromBalance = balances.find(b => 
        b.userId === settlement.fromUserId.toString()
      );
      if (fromBalance) {
        fromBalance.amount -= settlement.amount;
        fromBalance.owedAmount += settlement.amount;
      }

      // Add to receiver
      const toBalance = balances.find(b => 
        b.userId === settlement.toUserId.toString()
      );
      if (toBalance) {
        toBalance.amount += settlement.amount;
        toBalance.paidAmount += settlement.amount;
      }
    }

    return balances.sort((a, b) => b.amount - a.amount);
  }

  /**
   * Check if settlement exists
   */
  async existsById(id: string): Promise<boolean> {
    const count = await this.settlementModel.countDocuments({ _id: id });
    return count > 0;
  }

  /**
   * Find pending settlements by user
   */
  async findPendingSettlementsByUser(groupId: string, userId: string): Promise<SettlementDomain[]> {
    const userObjectId = new Types.ObjectId(userId);
    const settlements = await this.settlementModel.find({
      groupId: new Types.ObjectId(groupId),
      status: SettlementStatus.PENDING,
      $or: [
        { fromUserId: userObjectId },
        { toUserId: userObjectId },
      ],
    })
    .populate('fromUserId', 'name email')
    .populate('toUserId', 'name email')
    .exec();

    return settlements
      .map(settlement => SettlementMapper.toDomain(settlement))
      .filter(Boolean) as SettlementDomain[];
  }

  /**
   * Validate settlement
   */
  private validateSettlement(settlement: SettlementDomain): void {
    if (settlement.amount <= 0) {
      throw new SettlementValidationError('Amount must be greater than 0');
    }

    if (settlement.fromUserId === settlement.toUserId) {
      throw new SettlementValidationError('Cannot settle with yourself');
    }

    if (settlement.status === SettlementStatus.CANCELLED && settlement.isAutoGenerated) {
      throw new SettlementValidationError('Auto-generated settlements cannot be cancelled');
    }
  }

  /**
   * Validate status transition
   */
  private validateStatusTransition(currentStatus: SettlementStatus, newStatus: SettlementStatus): void {
    const validTransitions: Record<SettlementStatus, SettlementStatus[]> = {
      [SettlementStatus.PENDING]: [SettlementStatus.COMPLETED, SettlementStatus.CANCELLED],
      [SettlementStatus.COMPLETED]: [SettlementStatus.CANCELLED],
      [SettlementStatus.CANCELLED]: [],
    };

    if (!validTransitions[currentStatus]?.includes(newStatus)) {
      throw new SettlementValidationError(
        `Invalid status transition from ${currentStatus} to ${newStatus}`
      );
    }
  }
}