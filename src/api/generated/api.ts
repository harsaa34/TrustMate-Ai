/* tslint:disable */
/* eslint-disable */
/**
 * TrustMate AI - Expense Tracker API
 * Complete API for managing groups, expenses, and settlements between friends
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AddMemberDto {
    /**
     * User ID to add to the group
     */
    'userId': string;
    /**
     * Role for the new member
     */
    'role'?: AddMemberDtoRoleEnum;
}

export const AddMemberDtoRoleEnum = {
    Admin: 'admin',
    Member: 'member'
} as const;

export type AddMemberDtoRoleEnum = typeof AddMemberDtoRoleEnum[keyof typeof AddMemberDtoRoleEnum];

export interface AuthResponseDto {
    /**
     * JWT access token
     */
    'token': string;
    /**
     * Refresh token
     */
    'refreshToken'?: string;
    /**
     * User information
     */
    'user': UserResponseDto;
    /**
     * Session ID
     */
    'sessionId'?: string;
    /**
     * Security information
     */
    'security'?: object;
}
export interface BalanceResponseDto {
    /**
     * User ID
     */
    'userId': string;
    /**
     * User name
     */
    'userName': string;
    /**
     * Net balance (negative = owes, positive = is owed)
     */
    'amount': number;
    /**
     * Total amount paid by user
     */
    'paidAmount': number;
    /**
     * Total amount owed by user
     */
    'owedAmount': number;
    /**
     * Currency
     */
    'currency': string;
}
export interface ChangePasswordDto {
    /**
     * Current password
     */
    'currentPassword': string;
    /**
     * New password (must contain uppercase, lowercase, and number)
     */
    'newPassword': string;
}
export interface CreateExpenseDto {
    /**
     * Expense title
     */
    'title': string;
    /**
     * Expense description
     */
    'description'?: string;
    /**
     * Total expense amount
     */
    'amount': number;
    /**
     * User who paid for the expense
     */
    'paidByUserId': string;
    /**
     * Expense date
     */
    'date': string;
    /**
     * Expense category
     */
    'category'?: CreateExpenseDtoCategoryEnum;
    /**
     * Split type
     */
    'splitType': CreateExpenseDtoSplitTypeEnum;
    /**
     * Expense splits for each user (minimum 2 users)
     */
    'splits': Array<ExpenseSplitDto>;
    /**
     * Receipt image URL
     */
    'receiptImageUrl'?: string;
    /**
     * Expense location
     */
    'location'?: string;
    /**
     * Tags for categorization
     */
    'tags'?: Array<string>;
}

export const CreateExpenseDtoCategoryEnum = {
    Food: 'food',
    Transport: 'transport',
    Accommodation: 'accommodation',
    Shopping: 'shopping',
    Entertainment: 'entertainment',
    Bills: 'bills',
    Health: 'health',
    Education: 'education',
    Other: 'other'
} as const;

export type CreateExpenseDtoCategoryEnum = typeof CreateExpenseDtoCategoryEnum[keyof typeof CreateExpenseDtoCategoryEnum];
export const CreateExpenseDtoSplitTypeEnum = {
    Equal: 'equal',
    Percentage: 'percentage',
    Exact: 'exact',
    Shares: 'shares',
    Adjustment: 'adjustment'
} as const;

export type CreateExpenseDtoSplitTypeEnum = typeof CreateExpenseDtoSplitTypeEnum[keyof typeof CreateExpenseDtoSplitTypeEnum];

export interface CreateGroupDto {
    /**
     * Group name
     */
    'name': string;
    /**
     * Group description
     */
    'description'?: string;
    /**
     * Default currency for the group
     */
    'currency'?: CreateGroupDtoCurrencyEnum;
}

export const CreateGroupDtoCurrencyEnum = {
    Inr: 'INR',
    Usd: 'USD',
    Eur: 'EUR',
    Gbp: 'GBP'
} as const;

export type CreateGroupDtoCurrencyEnum = typeof CreateGroupDtoCurrencyEnum[keyof typeof CreateGroupDtoCurrencyEnum];

export interface CreateOptimizedSettlementsDto {
    /**
     * Automatically create optimized settlements
     */
    'autoCreate': boolean;
    /**
     * Maximum number of settlements to create
     */
    'maxSettlements'?: number;
}
export interface CreateSettlementDto {
    /**
     * User who owes money (payer)
     */
    'fromUserId': string;
    /**
     * User who is owed money (receiver)
     */
    'toUserId': string;
    /**
     * Settlement amount
     */
    'amount': number;
    /**
     * Settlement date
     */
    'date': string;
    /**
     * Settlement description
     */
    'description'?: string;
    /**
     * Payment method used
     */
    'paymentMethod'?: CreateSettlementDtoPaymentMethodEnum;
    /**
     * Transaction ID for reference
     */
    'transactionId'?: string;
    /**
     * Whether settlement was auto-generated
     */
    'isAutoGenerated'?: boolean;
}

export const CreateSettlementDtoPaymentMethodEnum = {
    Upi: 'UPI',
    Cash: 'CASH',
    BankTransfer: 'BANK_TRANSFER',
    CreditCard: 'CREDIT_CARD',
    DebitCard: 'DEBIT_CARD',
    Paytm: 'PAYTM',
    Phonepe: 'PHONEPE',
    GooglePay: 'GOOGLE_PAY'
} as const;

export type CreateSettlementDtoPaymentMethodEnum = typeof CreateSettlementDtoPaymentMethodEnum[keyof typeof CreateSettlementDtoPaymentMethodEnum];

export interface CreateUserDto {
    /**
     * User email address
     */
    'email': string;
    /**
     * User password
     */
    'password': string;
    /**
     * User full name
     */
    'name': string;
    /**
     * User phone number
     */
    'phone'?: string;
}
export interface ExpenseListResponseDto {
    /**
     * List of expenses
     */
    'expenses': Array<ExpenseResponseDto>;
    /**
     * Total count
     */
    'total': number;
    /**
     * Page number
     */
    'page': number;
    /**
     * Items per page
     */
    'limit': number;
    /**
     * Total pages
     */
    'totalPages': number;
}
export interface ExpenseResponseDto {
    /**
     * Expense ID
     */
    'id': string;
    /**
     * Group ID
     */
    'groupId': string;
    /**
     * Expense title
     */
    'title': string;
    /**
     * Expense description
     */
    'description'?: string;
    /**
     * Total expense amount
     */
    'amount': number;
    /**
     * User who paid for the expense
     */
    'paidByUserId': string;
    /**
     * Paid by user name
     */
    'paidByUserName'?: string;
    /**
     * Expense date
     */
    'date': string;
    /**
     * Expense category
     */
    'category'?: string;
    /**
     * Split type
     */
    'splitType': string;
    /**
     * Expense splits
     */
    'splits': Array<ExpenseSplitResponseDto>;
    /**
     * Receipt image URL
     */
    'receiptImageUrl'?: string;
    /**
     * Expense location
     */
    'location'?: string;
    /**
     * Tags for categorization
     */
    'tags'?: Array<string>;
    /**
     * Whether expense is verified
     */
    'verified': boolean;
    /**
     * Created by user ID
     */
    'createdByUserId': string;
    /**
     * Created by user name
     */
    'createdByUserName'?: string;
    /**
     * Creation timestamp
     */
    'createdAt': string;
    /**
     * Update timestamp
     */
    'updatedAt': string;
}
export interface ExpenseSplitDto {
    /**
     * User ID for this split
     */
    'userId': string;
    /**
     * Amount for this user (required for exact splits)
     */
    'amount'?: number;
    /**
     * Percentage for this user (required for percentage splits)
     */
    'percentage'?: number;
    /**
     * Shares for this user (required for share splits)
     */
    'shares'?: number;
    /**
     * Note for this split
     */
    'note'?: string;
}
export interface ExpenseSplitResponseDto {
    /**
     * User ID for this split
     */
    'userId': string;
    /**
     * Amount for this user
     */
    'amount': number;
    /**
     * Percentage for this user
     */
    'percentage'?: number;
    /**
     * Shares for this user
     */
    'shares'?: number;
    /**
     * Note for this split
     */
    'note'?: string;
}
export interface ForgotPasswordDto {
    /**
     * Email address for password reset
     */
    'email': string;
}
export interface GroupMemberResponseDto {
    /**
     * User ID
     */
    'userId': string;
    /**
     * User name
     */
    'userName': string;
    /**
     * User email
     */
    'userEmail': string;
    /**
     * Member role
     */
    'role': GroupMemberResponseDtoRoleEnum;
    /**
     * Join date
     */
    'joinedAt': string;
}

export const GroupMemberResponseDtoRoleEnum = {
    Admin: 'admin',
    Member: 'member'
} as const;

export type GroupMemberResponseDtoRoleEnum = typeof GroupMemberResponseDtoRoleEnum[keyof typeof GroupMemberResponseDtoRoleEnum];

export interface GroupResponseDto {
    /**
     * Group ID
     */
    'id': string;
    /**
     * Group name
     */
    'name': string;
    /**
     * Group description
     */
    'description'?: string;
    /**
     * Group creator
     */
    'createdBy': object;
    /**
     * Group members
     */
    'members': Array<GroupResponseDtoMembersInner>;
    /**
     * Group settings
     */
    'settings': object;
    /**
     * Whether the group is active
     */
    'isActive': boolean;
    /**
     * Creation date
     */
    'createdAt': string;
    /**
     * Last update date
     */
    'updatedAt': string;
}
export interface GroupResponseDtoMembersInner {
    'userId'?: string;
    'userName'?: string;
    'userEmail'?: string;
    'role'?: GroupResponseDtoMembersInnerRoleEnum;
    'joinedAt'?: string;
}

export const GroupResponseDtoMembersInnerRoleEnum = {
    Admin: 'admin',
    Member: 'member'
} as const;

export type GroupResponseDtoMembersInnerRoleEnum = typeof GroupResponseDtoMembersInnerRoleEnum[keyof typeof GroupResponseDtoMembersInnerRoleEnum];

export interface GroupStatisticsDto {
    /**
     * Group ID
     */
    'groupId': string;
    /**
     * Group name
     */
    'name': string;
    /**
     * Number of members
     */
    'memberCount': number;
    /**
     * Creation date
     */
    'createdAt': string;
}
export interface InsightResponseDto {
    /**
     * Total spent in period
     */
    'totalSpent': number;
    /**
     * Average per expense
     */
    'averagePerExpense': number;
    /**
     * Number of expenses
     */
    'expenseCount': number;
    /**
     * Top categories with amounts
     */
    'categories': object;
    /**
     * Daily spending breakdown
     */
    'dailyBreakdown': object;
}
export interface LoginDto {
    /**
     * User email address
     */
    'email': string;
    /**
     * User password
     */
    'password': string;
}
export interface LoginResponseDto {
    /**
     * JWT token
     */
    'token': string;
    /**
     * Authenticated user information
     */
    'user': UserResponseDto;
    /**
     * Refresh token
     */
    'refreshToken'?: string;
}
export interface RefreshTokenDto {
    /**
     * Refresh token
     */
    'refreshToken': string;
}
export interface ResetPasswordDto {
    /**
     * Reset token received via email
     */
    'token': string;
    /**
     * New password (must contain uppercase, lowercase, and number)
     */
    'newPassword': string;
}
export interface ResetPasswordLinkResponseDto {
    /**
     * Response message
     */
    'message': string;
    /**
     * Reset token (if valid)
     */
    'token'?: string;
    /**
     * Whether token is valid
     */
    'valid': boolean;
    /**
     * Instructions for resetting password
     */
    'instructions'?: string;
}
export interface SettlementListResponseDto {
    /**
     * List of settlements
     */
    'settlements': Array<SettlementResponseDto>;
    /**
     * Total number of settlements
     */
    'total': number;
    /**
     * Current page number
     */
    'page': number;
    /**
     * Items per page
     */
    'limit': number;
    /**
     * Total number of pages
     */
    'totalPages': number;
}
export interface SettlementOptimizationResultDto {
    /**
     * Payer user ID
     */
    'fromUserId': string;
    /**
     * Payer user name
     */
    'fromUserName': string;
    /**
     * Receiver user ID
     */
    'toUserId': string;
    /**
     * Receiver user name
     */
    'toUserName': string;
    /**
     * Settlement amount
     */
    'amount': number;
}
export interface SettlementResponseDto {
    /**
     * Settlement ID
     */
    'id': string;
    /**
     * Group ID
     */
    'groupId': string;
    /**
     * User who owes money (payer)
     */
    'fromUserId': string;
    /**
     * Payer user name
     */
    'fromUserName': string;
    /**
     * User who is owed money (receiver)
     */
    'toUserId': string;
    /**
     * Receiver user name
     */
    'toUserName': string;
    /**
     * Settlement amount
     */
    'amount': number;
    /**
     * Settlement date
     */
    'date': string;
    /**
     * Settlement status
     */
    'status': SettlementResponseDtoStatusEnum;
    /**
     * Settlement description
     */
    'description'?: string;
    /**
     * Payment method used
     */
    'paymentMethod'?: string;
    /**
     * Transaction ID
     */
    'transactionId'?: string;
    /**
     * Whether settlement was auto-generated
     */
    'isAutoGenerated': boolean;
    /**
     * Creation date
     */
    'createdAt': string;
    /**
     * Last update date
     */
    'updatedAt': string;
}

export const SettlementResponseDtoStatusEnum = {
    Pending: 'pending',
    Completed: 'completed',
    Cancelled: 'cancelled'
} as const;

export type SettlementResponseDtoStatusEnum = typeof SettlementResponseDtoStatusEnum[keyof typeof SettlementResponseDtoStatusEnum];

export interface SettlementStatisticsDto {
    /**
     * Total number of settlements
     */
    'totalSettlements': number;
    /**
     * Total amount settled
     */
    'totalAmount': number;
    /**
     * Total outstanding debt
     */
    'totalDebt': number;
    /**
     * Number of pending settlements
     */
    'pendingCount': number;
    /**
     * Number of completed settlements
     */
    'completedCount': number;
    /**
     * Number of cancelled settlements
     */
    'cancelledCount': number;
    /**
     * Recent settlements
     */
    'recentSettlements': Array<SettlementResponseDto>;
    /**
     * Current balances
     */
    'balances': Array<BalanceResponseDto>;
}
export interface SignUpDto {
    /**
     * User email address
     */
    'email': string;
    /**
     * User password (must contain uppercase, lowercase, and number)
     */
    'password': string;
    /**
     * User full name
     */
    'name': string;
    /**
     * User phone number
     */
    'phone'?: string;
}
export interface SuccessResponseDto {
    /**
     * Success message
     */
    'message': string;
}
export interface UpdateExpenseDto {
    /**
     * Expense title
     */
    'title'?: string;
    /**
     * Expense description
     */
    'description'?: string;
    /**
     * Total expense amount
     */
    'amount'?: number;
    /**
     * User who paid for the expense
     */
    'paidByUserId'?: string;
    /**
     * Expense date
     */
    'date'?: string;
    /**
     * Expense category
     */
    'category'?: UpdateExpenseDtoCategoryEnum;
    /**
     * Split type
     */
    'splitType'?: UpdateExpenseDtoSplitTypeEnum;
    /**
     * Updated expense splits (minimum 2 users)
     */
    'splits'?: Array<ExpenseSplitDto>;
    /**
     * Receipt image URL
     */
    'receiptImageUrl'?: string;
    /**
     * Mark expense as verified
     */
    'verified'?: boolean;
    /**
     * Expense location
     */
    'location'?: string;
    /**
     * Tags for categorization
     */
    'tags'?: Array<string>;
}

export const UpdateExpenseDtoCategoryEnum = {
    Food: 'food',
    Transport: 'transport',
    Accommodation: 'accommodation',
    Shopping: 'shopping',
    Entertainment: 'entertainment',
    Bills: 'bills',
    Health: 'health',
    Education: 'education',
    Other: 'other'
} as const;

export type UpdateExpenseDtoCategoryEnum = typeof UpdateExpenseDtoCategoryEnum[keyof typeof UpdateExpenseDtoCategoryEnum];
export const UpdateExpenseDtoSplitTypeEnum = {
    Equal: 'equal',
    Percentage: 'percentage',
    Exact: 'exact',
    Shares: 'shares',
    Adjustment: 'adjustment'
} as const;

export type UpdateExpenseDtoSplitTypeEnum = typeof UpdateExpenseDtoSplitTypeEnum[keyof typeof UpdateExpenseDtoSplitTypeEnum];

export interface UpdateGroupDto {
    /**
     * Group name
     */
    'name'?: string;
    /**
     * Group description
     */
    'description'?: string;
    /**
     * Default currency for the group
     */
    'currency'?: UpdateGroupDtoCurrencyEnum;
}

export const UpdateGroupDtoCurrencyEnum = {
    Inr: 'INR',
    Usd: 'USD',
    Eur: 'EUR',
    Gbp: 'GBP'
} as const;

export type UpdateGroupDtoCurrencyEnum = typeof UpdateGroupDtoCurrencyEnum[keyof typeof UpdateGroupDtoCurrencyEnum];

export interface UpdateProfileDto {
    /**
     * User full name
     */
    'name'?: string;
    /**
     * User phone number
     */
    'phone'?: string;
    /**
     * User biography
     */
    'bio'?: string;
    /**
     * Profile avatar URL
     */
    'avatar'?: string;
}
export interface UpdateSettlementStatusDto {
    /**
     * New settlement status
     */
    'status': UpdateSettlementStatusDtoStatusEnum;
}

export const UpdateSettlementStatusDtoStatusEnum = {
    Pending: 'pending',
    Completed: 'completed',
    Cancelled: 'cancelled'
} as const;

export type UpdateSettlementStatusDtoStatusEnum = typeof UpdateSettlementStatusDtoStatusEnum[keyof typeof UpdateSettlementStatusDtoStatusEnum];

export interface UserResponseDto {
    /**
     * User ID
     */
    'id': string;
    /**
     * User email address
     */
    'email': string;
    /**
     * User full name
     */
    'name': string;
    /**
     * Whether the user account is active
     */
    'isActive': boolean;
    /**
     * Whether the user email is verified
     */
    'isVerified': boolean;
    /**
     * User phone number
     */
    'phone'?: string;
    /**
     * User avatar URL
     */
    'avatar'?: string;
    /**
     * User biography
     */
    'bio'?: string;
    /**
     * Account creation date
     */
    'createdAt': string;
    /**
     * Last account update date
     */
    'updatedAt': string;
}
export interface VerifyReceiptDto {
    /**
     * Actual amount from receipt
     */
    'extractedAmount': number;
    /**
     * Extracted date from receipt
     */
    'extractedDate'?: string;
    /**
     * Confidence score of OCR extraction
     */
    'confidenceScore'?: number;
    /**
     * Additional verification metadata
     */
    'metadata'?: object;
}

/**
 * AppApi - axios parameter creator
 */
export const AppApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppApi - functional programming interface
 */
export const AppApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetHello(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetHello(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppApi.appControllerGetHello']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AppApi - factory interface
 */
export const AppApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.appControllerGetHello(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppApi - object-oriented interface
 */
export class AppApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public appControllerGetHello(options?: RawAxiosRequestConfig) {
        return AppApiFp(this.configuration).appControllerGetHello(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change user password
         * @summary Change user password
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerChangePassword: async (changePasswordDto: ChangePasswordDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordDto' is not null or undefined
            assertParamExists('authControllerChangePassword', 'changePasswordDto', changePasswordDto)
            const localVarPath = `/api/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if email is available for registration
         * @summary Check if email is available for registration
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCheckEmailAvailability: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('authControllerCheckEmailAvailability', 'email', email)
            const localVarPath = `/api/auth/check-email/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete user account (soft delete)
         * @summary Delete user account (soft delete)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerDeleteAccount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request password reset email
         * @summary Request password reset email
         * @param {ForgotPasswordDto} forgotPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerForgotPassword: async (forgotPasswordDto: ForgotPasswordDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordDto' is not null or undefined
            assertParamExists('authControllerForgotPassword', 'forgotPasswordDto', forgotPasswordDto)
            const localVarPath = `/api/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get authenticated user profile
         * @summary Get authenticated user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle reset password link from email
         * @summary Handle reset password link from email
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerHandleResetPasswordLink: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authControllerHandleResetPasswordLink', 'token', token)
            const localVarPath = `/api/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate user and return JWT tokens
         * @summary Authenticate user and return JWT tokens
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginDto: LoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authControllerLogin', 'loginDto', loginDto)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logout user and invalidate refresh token
         * @summary Logout user and invalidate refresh token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logout user from all devices
         * @summary Logout user from all devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogoutFromAllDevices: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout-all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh access token using refresh token
         * @summary Refresh access token using refresh token
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshToken: async (refreshTokenDto: RefreshTokenDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenDto' is not null or undefined
            assertParamExists('authControllerRefreshToken', 'refreshTokenDto', refreshTokenDto)
            const localVarPath = `/api/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend verification email
         * @summary Resend verification email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResendVerificationEmail: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/resend-verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset password using reset token
         * @summary Reset password using reset token
         * @param {ResetPasswordDto} resetPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPassword: async (resetPasswordDto: ResetPasswordDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordDto' is not null or undefined
            assertParamExists('authControllerResetPassword', 'resetPasswordDto', resetPasswordDto)
            const localVarPath = `/api/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new user account
         * @summary Register a new user account
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignup: async (signUpDto: SignUpDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpDto' is not null or undefined
            assertParamExists('authControllerSignup', 'signUpDto', signUpDto)
            const localVarPath = `/api/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update authenticated user profile
         * @summary Update authenticated user profile
         * @param {UpdateProfileDto} updateProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUpdateProfile: async (updateProfileDto: UpdateProfileDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateProfileDto' is not null or undefined
            assertParamExists('authControllerUpdateProfile', 'updateProfileDto', updateProfileDto)
            const localVarPath = `/api/auth/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProfileDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate JWT token
         * @summary Validate JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerValidateToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify email address using verification token
         * @summary Verify email address using verification token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyEmail: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authControllerVerifyEmail', 'token', token)
            const localVarPath = `/api/auth/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Change user password
         * @summary Change user password
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerChangePassword(changePasswordDto: ChangePasswordDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerChangePassword(changePasswordDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerChangePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check if email is available for registration
         * @summary Check if email is available for registration
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerCheckEmailAvailability(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerCheckEmailAvailability(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerCheckEmailAvailability']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete user account (soft delete)
         * @summary Delete user account (soft delete)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerDeleteAccount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerDeleteAccount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerDeleteAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request password reset email
         * @summary Request password reset email
         * @param {ForgotPasswordDto} forgotPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerForgotPassword(forgotPasswordDto: ForgotPasswordDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerForgotPassword(forgotPasswordDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerForgotPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get authenticated user profile
         * @summary Get authenticated user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerGetProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle reset password link from email
         * @summary Handle reset password link from email
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerHandleResetPasswordLink(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResetPasswordLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerHandleResetPasswordLink(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerHandleResetPasswordLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate user and return JWT tokens
         * @summary Authenticate user and return JWT tokens
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logout user and invalidate refresh token
         * @summary Logout user and invalidate refresh token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logout user from all devices
         * @summary Logout user from all devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogoutFromAllDevices(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogoutFromAllDevices(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerLogoutFromAllDevices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Refresh access token using refresh token
         * @summary Refresh access token using refresh token
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefreshToken(refreshTokenDto: RefreshTokenDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefreshToken(refreshTokenDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerRefreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resend verification email
         * @summary Resend verification email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerResendVerificationEmail(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerResendVerificationEmail(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerResendVerificationEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset password using reset token
         * @summary Reset password using reset token
         * @param {ResetPasswordDto} resetPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerResetPassword(resetPasswordDto: ResetPasswordDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerResetPassword(resetPasswordDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerResetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a new user account
         * @summary Register a new user account
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignup(signUpDto: SignUpDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignup(signUpDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerSignup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update authenticated user profile
         * @summary Update authenticated user profile
         * @param {UpdateProfileDto} updateProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerUpdateProfile(updateProfileDto: UpdateProfileDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerUpdateProfile(updateProfileDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerUpdateProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validate JWT token
         * @summary Validate JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerValidateToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerValidateToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerValidateToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify email address using verification token
         * @summary Verify email address using verification token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerVerifyEmail(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerVerifyEmail(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerVerifyEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Change user password
         * @summary Change user password
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerChangePassword(changePasswordDto: ChangePasswordDto, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.authControllerChangePassword(changePasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if email is available for registration
         * @summary Check if email is available for registration
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCheckEmailAvailability(email: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.authControllerCheckEmailAvailability(email, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete user account (soft delete)
         * @summary Delete user account (soft delete)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerDeleteAccount(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.authControllerDeleteAccount(options).then((request) => request(axios, basePath));
        },
        /**
         * Request password reset email
         * @summary Request password reset email
         * @param {ForgotPasswordDto} forgotPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerForgotPassword(forgotPasswordDto: ForgotPasswordDto, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.authControllerForgotPassword(forgotPasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Get authenticated user profile
         * @summary Get authenticated user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile(options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.authControllerGetProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * Handle reset password link from email
         * @summary Handle reset password link from email
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerHandleResetPasswordLink(token: string, options?: RawAxiosRequestConfig): AxiosPromise<ResetPasswordLinkResponseDto> {
            return localVarFp.authControllerHandleResetPasswordLink(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate user and return JWT tokens
         * @summary Authenticate user and return JWT tokens
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponseDto> {
            return localVarFp.authControllerLogin(loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Logout user and invalidate refresh token
         * @summary Logout user and invalidate refresh token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.authControllerLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * Logout user from all devices
         * @summary Logout user from all devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogoutFromAllDevices(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.authControllerLogoutFromAllDevices(options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh access token using refresh token
         * @summary Refresh access token using refresh token
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshToken(refreshTokenDto: RefreshTokenDto, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.authControllerRefreshToken(refreshTokenDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend verification email
         * @summary Resend verification email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResendVerificationEmail(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.authControllerResendVerificationEmail(options).then((request) => request(axios, basePath));
        },
        /**
         * Reset password using reset token
         * @summary Reset password using reset token
         * @param {ResetPasswordDto} resetPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPassword(resetPasswordDto: ResetPasswordDto, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.authControllerResetPassword(resetPasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new user account
         * @summary Register a new user account
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignup(signUpDto: SignUpDto, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponseDto> {
            return localVarFp.authControllerSignup(signUpDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update authenticated user profile
         * @summary Update authenticated user profile
         * @param {UpdateProfileDto} updateProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUpdateProfile(updateProfileDto: UpdateProfileDto, options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.authControllerUpdateProfile(updateProfileDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate JWT token
         * @summary Validate JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerValidateToken(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.authControllerValidateToken(options).then((request) => request(axios, basePath));
        },
        /**
         * Verify email address using verification token
         * @summary Verify email address using verification token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyEmail(token: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.authControllerVerifyEmail(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Change user password
     * @summary Change user password
     * @param {ChangePasswordDto} changePasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerChangePassword(changePasswordDto: ChangePasswordDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerChangePassword(changePasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if email is available for registration
     * @summary Check if email is available for registration
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerCheckEmailAvailability(email: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerCheckEmailAvailability(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete user account (soft delete)
     * @summary Delete user account (soft delete)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerDeleteAccount(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerDeleteAccount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request password reset email
     * @summary Request password reset email
     * @param {ForgotPasswordDto} forgotPasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerForgotPassword(forgotPasswordDto: ForgotPasswordDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerForgotPassword(forgotPasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get authenticated user profile
     * @summary Get authenticated user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerGetProfile(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerGetProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle reset password link from email
     * @summary Handle reset password link from email
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerHandleResetPasswordLink(token: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerHandleResetPasswordLink(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate user and return JWT tokens
     * @summary Authenticate user and return JWT tokens
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerLogin(loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logout user and invalidate refresh token
     * @summary Logout user and invalidate refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerLogout(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logout user from all devices
     * @summary Logout user from all devices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerLogoutFromAllDevices(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerLogoutFromAllDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh access token using refresh token
     * @summary Refresh access token using refresh token
     * @param {RefreshTokenDto} refreshTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerRefreshToken(refreshTokenDto: RefreshTokenDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerRefreshToken(refreshTokenDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resend verification email
     * @summary Resend verification email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerResendVerificationEmail(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerResendVerificationEmail(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset password using reset token
     * @summary Reset password using reset token
     * @param {ResetPasswordDto} resetPasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerResetPassword(resetPasswordDto: ResetPasswordDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerResetPassword(resetPasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a new user account
     * @summary Register a new user account
     * @param {SignUpDto} signUpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerSignup(signUpDto: SignUpDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerSignup(signUpDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update authenticated user profile
     * @summary Update authenticated user profile
     * @param {UpdateProfileDto} updateProfileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerUpdateProfile(updateProfileDto: UpdateProfileDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerUpdateProfile(updateProfileDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate JWT token
     * @summary Validate JWT token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerValidateToken(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerValidateToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify email address using verification token
     * @summary Verify email address using verification token
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerVerifyEmail(token: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerVerifyEmail(token, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExpensesApi - axios parameter creator
 */
export const ExpensesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new expense in a group
         * @summary Create a new expense in a group
         * @param {string} groupId Group ID
         * @param {CreateExpenseDto} createExpenseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerCreateExpense: async (groupId: string, createExpenseDto: CreateExpenseDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('expenseControllerCreateExpense', 'groupId', groupId)
            // verify required parameter 'createExpenseDto' is not null or undefined
            assertParamExists('expenseControllerCreateExpense', 'createExpenseDto', createExpenseDto)
            const localVarPath = `/api/groups/{groupId}/expenses`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createExpenseDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an expense
         * @summary Delete an expense
         * @param {string} groupId Group ID
         * @param {string} expenseId Expense ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerDeleteExpense: async (groupId: string, expenseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('expenseControllerDeleteExpense', 'groupId', groupId)
            // verify required parameter 'expenseId' is not null or undefined
            assertParamExists('expenseControllerDeleteExpense', 'expenseId', expenseId)
            const localVarPath = `/api/groups/{groupId}/expenses/{expenseId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"expenseId"}}`, encodeURIComponent(String(expenseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calculate balances for all group members
         * @summary Calculate balances for all group members
         * @param {string} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerGetBalances: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('expenseControllerGetBalances', 'groupId', groupId)
            const localVarPath = `/api/groups/{groupId}/expenses/balances`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get expense by ID
         * @summary Get expense by ID
         * @param {string} groupId Group ID
         * @param {string} expenseId Expense ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerGetExpenseById: async (groupId: string, expenseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('expenseControllerGetExpenseById', 'groupId', groupId)
            // verify required parameter 'expenseId' is not null or undefined
            assertParamExists('expenseControllerGetExpenseById', 'expenseId', expenseId)
            const localVarPath = `/api/groups/{groupId}/expenses/{expenseId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"expenseId"}}`, encodeURIComponent(String(expenseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get expense summary for a group
         * @summary Get expense summary for a group
         * @param {string} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerGetExpenseSummary: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('expenseControllerGetExpenseSummary', 'groupId', groupId)
            const localVarPath = `/api/groups/{groupId}/expenses/summary`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all expenses for a group with filters
         * @summary Get all expenses for a group with filters
         * @param {string} groupId Group ID
         * @param {ExpenseControllerGetGroupExpensesCategoryEnum} [category] Filter by category
         * @param {string} [fromDate] Filter from date
         * @param {string} [toDate] Filter to date
         * @param {string} [paidByUserId] Filter by paid by user ID
         * @param {boolean} [verified] Filter by verified status
         * @param {string} [search] Search in title and description
         * @param {ExpenseControllerGetGroupExpensesSortByEnum} [sortBy] Sort field
         * @param {ExpenseControllerGetGroupExpensesSortOrderEnum} [sortOrder] Sort direction
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerGetGroupExpenses: async (groupId: string, category?: ExpenseControllerGetGroupExpensesCategoryEnum, fromDate?: string, toDate?: string, paidByUserId?: string, verified?: boolean, search?: string, sortBy?: ExpenseControllerGetGroupExpensesSortByEnum, sortOrder?: ExpenseControllerGetGroupExpensesSortOrderEnum, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('expenseControllerGetGroupExpenses', 'groupId', groupId)
            const localVarPath = `/api/groups/{groupId}/expenses`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }

            if (paidByUserId !== undefined) {
                localVarQueryParameter['paidByUserId'] = paidByUserId;
            }

            if (verified !== undefined) {
                localVarQueryParameter['verified'] = verified;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get spending insights for a group
         * @summary Get spending insights for a group
         * @param {string} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerGetSpendingInsights: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('expenseControllerGetSpendingInsights', 'groupId', groupId)
            const localVarPath = `/api/groups/{groupId}/expenses/insights`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an expense
         * @summary Update an expense
         * @param {string} groupId Group ID
         * @param {string} expenseId Expense ID
         * @param {UpdateExpenseDto} updateExpenseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerUpdateExpense: async (groupId: string, expenseId: string, updateExpenseDto: UpdateExpenseDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('expenseControllerUpdateExpense', 'groupId', groupId)
            // verify required parameter 'expenseId' is not null or undefined
            assertParamExists('expenseControllerUpdateExpense', 'expenseId', expenseId)
            // verify required parameter 'updateExpenseDto' is not null or undefined
            assertParamExists('expenseControllerUpdateExpense', 'updateExpenseDto', updateExpenseDto)
            const localVarPath = `/api/groups/{groupId}/expenses/{expenseId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"expenseId"}}`, encodeURIComponent(String(expenseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateExpenseDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload receipt image
         * @summary Upload receipt image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerUploadReceipt: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/groups/{groupId}/expenses/upload-receipt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify receipt for an expense
         * @summary Verify receipt for an expense
         * @param {string} groupId Group ID
         * @param {string} expenseId Expense ID
         * @param {VerifyReceiptDto} verifyReceiptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerVerifyReceipt: async (groupId: string, expenseId: string, verifyReceiptDto: VerifyReceiptDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('expenseControllerVerifyReceipt', 'groupId', groupId)
            // verify required parameter 'expenseId' is not null or undefined
            assertParamExists('expenseControllerVerifyReceipt', 'expenseId', expenseId)
            // verify required parameter 'verifyReceiptDto' is not null or undefined
            assertParamExists('expenseControllerVerifyReceipt', 'verifyReceiptDto', verifyReceiptDto)
            const localVarPath = `/api/groups/{groupId}/expenses/{expenseId}/verify`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"expenseId"}}`, encodeURIComponent(String(expenseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyReceiptDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExpensesApi - functional programming interface
 */
export const ExpensesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExpensesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new expense in a group
         * @summary Create a new expense in a group
         * @param {string} groupId Group ID
         * @param {CreateExpenseDto} createExpenseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseControllerCreateExpense(groupId: string, createExpenseDto: CreateExpenseDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpenseResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseControllerCreateExpense(groupId, createExpenseDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpensesApi.expenseControllerCreateExpense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an expense
         * @summary Delete an expense
         * @param {string} groupId Group ID
         * @param {string} expenseId Expense ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseControllerDeleteExpense(groupId: string, expenseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseControllerDeleteExpense(groupId, expenseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpensesApi.expenseControllerDeleteExpense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Calculate balances for all group members
         * @summary Calculate balances for all group members
         * @param {string} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseControllerGetBalances(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseControllerGetBalances(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpensesApi.expenseControllerGetBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get expense by ID
         * @summary Get expense by ID
         * @param {string} groupId Group ID
         * @param {string} expenseId Expense ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseControllerGetExpenseById(groupId: string, expenseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpenseResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseControllerGetExpenseById(groupId, expenseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpensesApi.expenseControllerGetExpenseById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get expense summary for a group
         * @summary Get expense summary for a group
         * @param {string} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseControllerGetExpenseSummary(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseControllerGetExpenseSummary(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpensesApi.expenseControllerGetExpenseSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all expenses for a group with filters
         * @summary Get all expenses for a group with filters
         * @param {string} groupId Group ID
         * @param {ExpenseControllerGetGroupExpensesCategoryEnum} [category] Filter by category
         * @param {string} [fromDate] Filter from date
         * @param {string} [toDate] Filter to date
         * @param {string} [paidByUserId] Filter by paid by user ID
         * @param {boolean} [verified] Filter by verified status
         * @param {string} [search] Search in title and description
         * @param {ExpenseControllerGetGroupExpensesSortByEnum} [sortBy] Sort field
         * @param {ExpenseControllerGetGroupExpensesSortOrderEnum} [sortOrder] Sort direction
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseControllerGetGroupExpenses(groupId: string, category?: ExpenseControllerGetGroupExpensesCategoryEnum, fromDate?: string, toDate?: string, paidByUserId?: string, verified?: boolean, search?: string, sortBy?: ExpenseControllerGetGroupExpensesSortByEnum, sortOrder?: ExpenseControllerGetGroupExpensesSortOrderEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpenseListResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseControllerGetGroupExpenses(groupId, category, fromDate, toDate, paidByUserId, verified, search, sortBy, sortOrder, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpensesApi.expenseControllerGetGroupExpenses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get spending insights for a group
         * @summary Get spending insights for a group
         * @param {string} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseControllerGetSpendingInsights(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsightResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseControllerGetSpendingInsights(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpensesApi.expenseControllerGetSpendingInsights']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an expense
         * @summary Update an expense
         * @param {string} groupId Group ID
         * @param {string} expenseId Expense ID
         * @param {UpdateExpenseDto} updateExpenseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseControllerUpdateExpense(groupId: string, expenseId: string, updateExpenseDto: UpdateExpenseDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpenseResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseControllerUpdateExpense(groupId, expenseId, updateExpenseDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpensesApi.expenseControllerUpdateExpense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload receipt image
         * @summary Upload receipt image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseControllerUploadReceipt(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseControllerUploadReceipt(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpensesApi.expenseControllerUploadReceipt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify receipt for an expense
         * @summary Verify receipt for an expense
         * @param {string} groupId Group ID
         * @param {string} expenseId Expense ID
         * @param {VerifyReceiptDto} verifyReceiptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expenseControllerVerifyReceipt(groupId: string, expenseId: string, verifyReceiptDto: VerifyReceiptDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expenseControllerVerifyReceipt(groupId, expenseId, verifyReceiptDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpensesApi.expenseControllerVerifyReceipt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExpensesApi - factory interface
 */
export const ExpensesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExpensesApiFp(configuration)
    return {
        /**
         * Create a new expense in a group
         * @summary Create a new expense in a group
         * @param {string} groupId Group ID
         * @param {CreateExpenseDto} createExpenseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerCreateExpense(groupId: string, createExpenseDto: CreateExpenseDto, options?: RawAxiosRequestConfig): AxiosPromise<ExpenseResponseDto> {
            return localVarFp.expenseControllerCreateExpense(groupId, createExpenseDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an expense
         * @summary Delete an expense
         * @param {string} groupId Group ID
         * @param {string} expenseId Expense ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerDeleteExpense(groupId: string, expenseId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.expenseControllerDeleteExpense(groupId, expenseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Calculate balances for all group members
         * @summary Calculate balances for all group members
         * @param {string} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerGetBalances(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<BalanceResponseDto>> {
            return localVarFp.expenseControllerGetBalances(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get expense by ID
         * @summary Get expense by ID
         * @param {string} groupId Group ID
         * @param {string} expenseId Expense ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerGetExpenseById(groupId: string, expenseId: string, options?: RawAxiosRequestConfig): AxiosPromise<ExpenseResponseDto> {
            return localVarFp.expenseControllerGetExpenseById(groupId, expenseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get expense summary for a group
         * @summary Get expense summary for a group
         * @param {string} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerGetExpenseSummary(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.expenseControllerGetExpenseSummary(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all expenses for a group with filters
         * @summary Get all expenses for a group with filters
         * @param {string} groupId Group ID
         * @param {ExpenseControllerGetGroupExpensesCategoryEnum} [category] Filter by category
         * @param {string} [fromDate] Filter from date
         * @param {string} [toDate] Filter to date
         * @param {string} [paidByUserId] Filter by paid by user ID
         * @param {boolean} [verified] Filter by verified status
         * @param {string} [search] Search in title and description
         * @param {ExpenseControllerGetGroupExpensesSortByEnum} [sortBy] Sort field
         * @param {ExpenseControllerGetGroupExpensesSortOrderEnum} [sortOrder] Sort direction
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerGetGroupExpenses(groupId: string, category?: ExpenseControllerGetGroupExpensesCategoryEnum, fromDate?: string, toDate?: string, paidByUserId?: string, verified?: boolean, search?: string, sortBy?: ExpenseControllerGetGroupExpensesSortByEnum, sortOrder?: ExpenseControllerGetGroupExpensesSortOrderEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ExpenseListResponseDto> {
            return localVarFp.expenseControllerGetGroupExpenses(groupId, category, fromDate, toDate, paidByUserId, verified, search, sortBy, sortOrder, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get spending insights for a group
         * @summary Get spending insights for a group
         * @param {string} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerGetSpendingInsights(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<InsightResponseDto> {
            return localVarFp.expenseControllerGetSpendingInsights(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an expense
         * @summary Update an expense
         * @param {string} groupId Group ID
         * @param {string} expenseId Expense ID
         * @param {UpdateExpenseDto} updateExpenseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerUpdateExpense(groupId: string, expenseId: string, updateExpenseDto: UpdateExpenseDto, options?: RawAxiosRequestConfig): AxiosPromise<ExpenseResponseDto> {
            return localVarFp.expenseControllerUpdateExpense(groupId, expenseId, updateExpenseDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload receipt image
         * @summary Upload receipt image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerUploadReceipt(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.expenseControllerUploadReceipt(options).then((request) => request(axios, basePath));
        },
        /**
         * Verify receipt for an expense
         * @summary Verify receipt for an expense
         * @param {string} groupId Group ID
         * @param {string} expenseId Expense ID
         * @param {VerifyReceiptDto} verifyReceiptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expenseControllerVerifyReceipt(groupId: string, expenseId: string, verifyReceiptDto: VerifyReceiptDto, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.expenseControllerVerifyReceipt(groupId, expenseId, verifyReceiptDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExpensesApi - object-oriented interface
 */
export class ExpensesApi extends BaseAPI {
    /**
     * Create a new expense in a group
     * @summary Create a new expense in a group
     * @param {string} groupId Group ID
     * @param {CreateExpenseDto} createExpenseDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public expenseControllerCreateExpense(groupId: string, createExpenseDto: CreateExpenseDto, options?: RawAxiosRequestConfig) {
        return ExpensesApiFp(this.configuration).expenseControllerCreateExpense(groupId, createExpenseDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an expense
     * @summary Delete an expense
     * @param {string} groupId Group ID
     * @param {string} expenseId Expense ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public expenseControllerDeleteExpense(groupId: string, expenseId: string, options?: RawAxiosRequestConfig) {
        return ExpensesApiFp(this.configuration).expenseControllerDeleteExpense(groupId, expenseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calculate balances for all group members
     * @summary Calculate balances for all group members
     * @param {string} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public expenseControllerGetBalances(groupId: string, options?: RawAxiosRequestConfig) {
        return ExpensesApiFp(this.configuration).expenseControllerGetBalances(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get expense by ID
     * @summary Get expense by ID
     * @param {string} groupId Group ID
     * @param {string} expenseId Expense ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public expenseControllerGetExpenseById(groupId: string, expenseId: string, options?: RawAxiosRequestConfig) {
        return ExpensesApiFp(this.configuration).expenseControllerGetExpenseById(groupId, expenseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get expense summary for a group
     * @summary Get expense summary for a group
     * @param {string} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public expenseControllerGetExpenseSummary(groupId: string, options?: RawAxiosRequestConfig) {
        return ExpensesApiFp(this.configuration).expenseControllerGetExpenseSummary(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all expenses for a group with filters
     * @summary Get all expenses for a group with filters
     * @param {string} groupId Group ID
     * @param {ExpenseControllerGetGroupExpensesCategoryEnum} [category] Filter by category
     * @param {string} [fromDate] Filter from date
     * @param {string} [toDate] Filter to date
     * @param {string} [paidByUserId] Filter by paid by user ID
     * @param {boolean} [verified] Filter by verified status
     * @param {string} [search] Search in title and description
     * @param {ExpenseControllerGetGroupExpensesSortByEnum} [sortBy] Sort field
     * @param {ExpenseControllerGetGroupExpensesSortOrderEnum} [sortOrder] Sort direction
     * @param {number} [page] Page number
     * @param {number} [limit] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public expenseControllerGetGroupExpenses(groupId: string, category?: ExpenseControllerGetGroupExpensesCategoryEnum, fromDate?: string, toDate?: string, paidByUserId?: string, verified?: boolean, search?: string, sortBy?: ExpenseControllerGetGroupExpensesSortByEnum, sortOrder?: ExpenseControllerGetGroupExpensesSortOrderEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ExpensesApiFp(this.configuration).expenseControllerGetGroupExpenses(groupId, category, fromDate, toDate, paidByUserId, verified, search, sortBy, sortOrder, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get spending insights for a group
     * @summary Get spending insights for a group
     * @param {string} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public expenseControllerGetSpendingInsights(groupId: string, options?: RawAxiosRequestConfig) {
        return ExpensesApiFp(this.configuration).expenseControllerGetSpendingInsights(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an expense
     * @summary Update an expense
     * @param {string} groupId Group ID
     * @param {string} expenseId Expense ID
     * @param {UpdateExpenseDto} updateExpenseDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public expenseControllerUpdateExpense(groupId: string, expenseId: string, updateExpenseDto: UpdateExpenseDto, options?: RawAxiosRequestConfig) {
        return ExpensesApiFp(this.configuration).expenseControllerUpdateExpense(groupId, expenseId, updateExpenseDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload receipt image
     * @summary Upload receipt image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public expenseControllerUploadReceipt(options?: RawAxiosRequestConfig) {
        return ExpensesApiFp(this.configuration).expenseControllerUploadReceipt(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify receipt for an expense
     * @summary Verify receipt for an expense
     * @param {string} groupId Group ID
     * @param {string} expenseId Expense ID
     * @param {VerifyReceiptDto} verifyReceiptDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public expenseControllerVerifyReceipt(groupId: string, expenseId: string, verifyReceiptDto: VerifyReceiptDto, options?: RawAxiosRequestConfig) {
        return ExpensesApiFp(this.configuration).expenseControllerVerifyReceipt(groupId, expenseId, verifyReceiptDto, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ExpenseControllerGetGroupExpensesCategoryEnum = {
    Food: 'food',
    Transport: 'transport',
    Accommodation: 'accommodation',
    Shopping: 'shopping',
    Entertainment: 'entertainment',
    Bills: 'bills',
    Health: 'health',
    Education: 'education',
    Other: 'other'
} as const;
export type ExpenseControllerGetGroupExpensesCategoryEnum = typeof ExpenseControllerGetGroupExpensesCategoryEnum[keyof typeof ExpenseControllerGetGroupExpensesCategoryEnum];
export const ExpenseControllerGetGroupExpensesSortByEnum = {
    Date: 'date',
    Amount: 'amount',
    CreatedAt: 'createdAt'
} as const;
export type ExpenseControllerGetGroupExpensesSortByEnum = typeof ExpenseControllerGetGroupExpensesSortByEnum[keyof typeof ExpenseControllerGetGroupExpensesSortByEnum];
export const ExpenseControllerGetGroupExpensesSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ExpenseControllerGetGroupExpensesSortOrderEnum = typeof ExpenseControllerGetGroupExpensesSortOrderEnum[keyof typeof ExpenseControllerGetGroupExpensesSortOrderEnum];


/**
 * GroupsApi - axios parameter creator
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add member to group
         * @summary Add member to group
         * @param {string} id 
         * @param {AddMemberDto} addMemberDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerAddMember: async (id: string, addMemberDto: AddMemberDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupControllerAddMember', 'id', id)
            // verify required parameter 'addMemberDto' is not null or undefined
            assertParamExists('groupControllerAddMember', 'addMemberDto', addMemberDto)
            const localVarPath = `/api/groups/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addMemberDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new group
         * @summary Create a new group
         * @param {CreateGroupDto} createGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerCreateGroup: async (createGroupDto: CreateGroupDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGroupDto' is not null or undefined
            assertParamExists('groupControllerCreateGroup', 'createGroupDto', createGroupDto)
            const localVarPath = `/api/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete group
         * @summary Delete group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerDeleteGroup: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupControllerDeleteGroup', 'id', id)
            const localVarPath = `/api/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get group details
         * @summary Get group details
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupControllerGetGroupById', 'id', id)
            const localVarPath = `/api/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get group members
         * @summary Get group members
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupMembers: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupControllerGetGroupMembers', 'id', id)
            const localVarPath = `/api/groups/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get group statistics
         * @summary Get group statistics
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupStatistics: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupControllerGetGroupStatistics', 'id', id)
            const localVarPath = `/api/groups/{id}/stats`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s groups
         * @summary Get user\'s groups
         * @param {GroupControllerGetUserGroupsSortByEnum} [sortBy] Field to sort by
         * @param {GroupControllerGetUserGroupsSortOrderEnum} [sortOrder] Sort order
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetUserGroups: async (sortBy?: GroupControllerGetUserGroupsSortByEnum, sortOrder?: GroupControllerGetUserGroupsSortOrderEnum, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove member from group
         * @summary Remove member from group
         * @param {string} id 
         * @param {string} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerRemoveMember: async (id: string, memberId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupControllerRemoveMember', 'id', id)
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('groupControllerRemoveMember', 'memberId', memberId)
            const localVarPath = `/api/groups/{id}/members/{memberId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update group
         * @summary Update group
         * @param {string} id 
         * @param {UpdateGroupDto} updateGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerUpdateGroup: async (id: string, updateGroupDto: UpdateGroupDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupControllerUpdateGroup', 'id', id)
            // verify required parameter 'updateGroupDto' is not null or undefined
            assertParamExists('groupControllerUpdateGroup', 'updateGroupDto', updateGroupDto)
            const localVarPath = `/api/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGroupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add member to group
         * @summary Add member to group
         * @param {string} id 
         * @param {AddMemberDto} addMemberDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerAddMember(id: string, addMemberDto: AddMemberDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerAddMember(id, addMemberDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupControllerAddMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new group
         * @summary Create a new group
         * @param {CreateGroupDto} createGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerCreateGroup(createGroupDto: CreateGroupDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerCreateGroup(createGroupDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupControllerCreateGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete group
         * @summary Delete group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerDeleteGroup(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerDeleteGroup(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupControllerDeleteGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get group details
         * @summary Get group details
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerGetGroupById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerGetGroupById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupControllerGetGroupById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get group members
         * @summary Get group members
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerGetGroupMembers(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupMemberResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerGetGroupMembers(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupControllerGetGroupMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get group statistics
         * @summary Get group statistics
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerGetGroupStatistics(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupStatisticsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerGetGroupStatistics(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupControllerGetGroupStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user\'s groups
         * @summary Get user\'s groups
         * @param {GroupControllerGetUserGroupsSortByEnum} [sortBy] Field to sort by
         * @param {GroupControllerGetUserGroupsSortOrderEnum} [sortOrder] Sort order
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerGetUserGroups(sortBy?: GroupControllerGetUserGroupsSortByEnum, sortOrder?: GroupControllerGetUserGroupsSortOrderEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerGetUserGroups(sortBy, sortOrder, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupControllerGetUserGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove member from group
         * @summary Remove member from group
         * @param {string} id 
         * @param {string} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerRemoveMember(id: string, memberId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerRemoveMember(id, memberId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupControllerRemoveMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update group
         * @summary Update group
         * @param {string} id 
         * @param {UpdateGroupDto} updateGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerUpdateGroup(id: string, updateGroupDto: UpdateGroupDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerUpdateGroup(id, updateGroupDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupControllerUpdateGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupsApi - factory interface
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * Add member to group
         * @summary Add member to group
         * @param {string} id 
         * @param {AddMemberDto} addMemberDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerAddMember(id: string, addMemberDto: AddMemberDto, options?: RawAxiosRequestConfig): AxiosPromise<GroupResponseDto> {
            return localVarFp.groupControllerAddMember(id, addMemberDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new group
         * @summary Create a new group
         * @param {CreateGroupDto} createGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerCreateGroup(createGroupDto: CreateGroupDto, options?: RawAxiosRequestConfig): AxiosPromise<GroupResponseDto> {
            return localVarFp.groupControllerCreateGroup(createGroupDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete group
         * @summary Delete group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerDeleteGroup(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.groupControllerDeleteGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get group details
         * @summary Get group details
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GroupResponseDto> {
            return localVarFp.groupControllerGetGroupById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get group members
         * @summary Get group members
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupMembers(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GroupMemberResponseDto>> {
            return localVarFp.groupControllerGetGroupMembers(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get group statistics
         * @summary Get group statistics
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupStatistics(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GroupStatisticsDto> {
            return localVarFp.groupControllerGetGroupStatistics(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s groups
         * @summary Get user\'s groups
         * @param {GroupControllerGetUserGroupsSortByEnum} [sortBy] Field to sort by
         * @param {GroupControllerGetUserGroupsSortOrderEnum} [sortOrder] Sort order
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetUserGroups(sortBy?: GroupControllerGetUserGroupsSortByEnum, sortOrder?: GroupControllerGetUserGroupsSortOrderEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<GroupResponseDto>> {
            return localVarFp.groupControllerGetUserGroups(sortBy, sortOrder, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove member from group
         * @summary Remove member from group
         * @param {string} id 
         * @param {string} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerRemoveMember(id: string, memberId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.groupControllerRemoveMember(id, memberId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update group
         * @summary Update group
         * @param {string} id 
         * @param {UpdateGroupDto} updateGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerUpdateGroup(id: string, updateGroupDto: UpdateGroupDto, options?: RawAxiosRequestConfig): AxiosPromise<GroupResponseDto> {
            return localVarFp.groupControllerUpdateGroup(id, updateGroupDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 */
export class GroupsApi extends BaseAPI {
    /**
     * Add member to group
     * @summary Add member to group
     * @param {string} id 
     * @param {AddMemberDto} addMemberDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public groupControllerAddMember(id: string, addMemberDto: AddMemberDto, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupControllerAddMember(id, addMemberDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new group
     * @summary Create a new group
     * @param {CreateGroupDto} createGroupDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public groupControllerCreateGroup(createGroupDto: CreateGroupDto, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupControllerCreateGroup(createGroupDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete group
     * @summary Delete group
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public groupControllerDeleteGroup(id: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupControllerDeleteGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get group details
     * @summary Get group details
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public groupControllerGetGroupById(id: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupControllerGetGroupById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get group members
     * @summary Get group members
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public groupControllerGetGroupMembers(id: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupControllerGetGroupMembers(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get group statistics
     * @summary Get group statistics
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public groupControllerGetGroupStatistics(id: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupControllerGetGroupStatistics(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s groups
     * @summary Get user\'s groups
     * @param {GroupControllerGetUserGroupsSortByEnum} [sortBy] Field to sort by
     * @param {GroupControllerGetUserGroupsSortOrderEnum} [sortOrder] Sort order
     * @param {number} [page] Page number
     * @param {number} [limit] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public groupControllerGetUserGroups(sortBy?: GroupControllerGetUserGroupsSortByEnum, sortOrder?: GroupControllerGetUserGroupsSortOrderEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupControllerGetUserGroups(sortBy, sortOrder, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove member from group
     * @summary Remove member from group
     * @param {string} id 
     * @param {string} memberId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public groupControllerRemoveMember(id: string, memberId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupControllerRemoveMember(id, memberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update group
     * @summary Update group
     * @param {string} id 
     * @param {UpdateGroupDto} updateGroupDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public groupControllerUpdateGroup(id: string, updateGroupDto: UpdateGroupDto, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupControllerUpdateGroup(id, updateGroupDto, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GroupControllerGetUserGroupsSortByEnum = {
    Name: 'name',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;
export type GroupControllerGetUserGroupsSortByEnum = typeof GroupControllerGetUserGroupsSortByEnum[keyof typeof GroupControllerGetUserGroupsSortByEnum];
export const GroupControllerGetUserGroupsSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GroupControllerGetUserGroupsSortOrderEnum = typeof GroupControllerGetUserGroupsSortOrderEnum[keyof typeof GroupControllerGetUserGroupsSortOrderEnum];


/**
 * SettlementsApi - axios parameter creator
 */
export const SettlementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create optimized settlements automatically
         * @summary Create optimized settlements automatically
         * @param {string} groupId 
         * @param {CreateOptimizedSettlementsDto} createOptimizedSettlementsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settlementControllerCreateOptimizedSettlements: async (groupId: string, createOptimizedSettlementsDto: CreateOptimizedSettlementsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('settlementControllerCreateOptimizedSettlements', 'groupId', groupId)
            // verify required parameter 'createOptimizedSettlementsDto' is not null or undefined
            assertParamExists('settlementControllerCreateOptimizedSettlements', 'createOptimizedSettlementsDto', createOptimizedSettlementsDto)
            const localVarPath = `/api/groups/{groupId}/settlements/optimize/auto-create`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOptimizedSettlementsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new settlement
         * @summary Create a new settlement
         * @param {string} groupId 
         * @param {CreateSettlementDto} createSettlementDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settlementControllerCreateSettlement: async (groupId: string, createSettlementDto: CreateSettlementDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('settlementControllerCreateSettlement', 'groupId', groupId)
            // verify required parameter 'createSettlementDto' is not null or undefined
            assertParamExists('settlementControllerCreateSettlement', 'createSettlementDto', createSettlementDto)
            const localVarPath = `/api/groups/{groupId}/settlements`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSettlementDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a settlement
         * @summary Delete a settlement
         * @param {string} groupId 
         * @param {string} settlementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settlementControllerDeleteSettlement: async (groupId: string, settlementId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('settlementControllerDeleteSettlement', 'groupId', groupId)
            // verify required parameter 'settlementId' is not null or undefined
            assertParamExists('settlementControllerDeleteSettlement', 'settlementId', settlementId)
            const localVarPath = `/api/groups/{groupId}/settlements/{settlementId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"settlementId"}}`, encodeURIComponent(String(settlementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calculate balances for all group members
         * @summary Calculate balances for all group members
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settlementControllerGetBalances: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('settlementControllerGetBalances', 'groupId', groupId)
            const localVarPath = `/api/groups/{groupId}/settlements/balances`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all settlements for a group
         * @summary Get all settlements for a group
         * @param {string} groupId 
         * @param {SettlementControllerGetGroupSettlementsStatusEnum} [status] Filter by status
         * @param {string} [fromDate] Filter from date
         * @param {string} [toDate] Filter to date
         * @param {string} [userId] Filter by user ID
         * @param {boolean} [isAutoGenerated] Filter by auto-generated settlements
         * @param {SettlementControllerGetGroupSettlementsSortByEnum} [sortBy] Sort by field
         * @param {SettlementControllerGetGroupSettlementsSortOrderEnum} [sortOrder] Sort order
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settlementControllerGetGroupSettlements: async (groupId: string, status?: SettlementControllerGetGroupSettlementsStatusEnum, fromDate?: string, toDate?: string, userId?: string, isAutoGenerated?: boolean, sortBy?: SettlementControllerGetGroupSettlementsSortByEnum, sortOrder?: SettlementControllerGetGroupSettlementsSortOrderEnum, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('settlementControllerGetGroupSettlements', 'groupId', groupId)
            const localVarPath = `/api/groups/{groupId}/settlements`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (isAutoGenerated !== undefined) {
                localVarQueryParameter['isAutoGenerated'] = isAutoGenerated;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get optimized settlement suggestions
         * @summary Get optimized settlement suggestions
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settlementControllerGetOptimizedSettlements: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('settlementControllerGetOptimizedSettlements', 'groupId', groupId)
            const localVarPath = `/api/groups/{groupId}/settlements/optimize`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get settlement by ID
         * @summary Get settlement by ID
         * @param {string} groupId 
         * @param {string} settlementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settlementControllerGetSettlementById: async (groupId: string, settlementId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('settlementControllerGetSettlementById', 'groupId', groupId)
            // verify required parameter 'settlementId' is not null or undefined
            assertParamExists('settlementControllerGetSettlementById', 'settlementId', settlementId)
            const localVarPath = `/api/groups/{groupId}/settlements/{settlementId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"settlementId"}}`, encodeURIComponent(String(settlementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get settlement statistics
         * @summary Get settlement statistics
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settlementControllerGetStatistics: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('settlementControllerGetStatistics', 'groupId', groupId)
            const localVarPath = `/api/groups/{groupId}/settlements/statistics`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update settlement status
         * @summary Update settlement status
         * @param {string} groupId 
         * @param {string} settlementId 
         * @param {UpdateSettlementStatusDto} updateSettlementStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settlementControllerUpdateSettlementStatus: async (groupId: string, settlementId: string, updateSettlementStatusDto: UpdateSettlementStatusDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('settlementControllerUpdateSettlementStatus', 'groupId', groupId)
            // verify required parameter 'settlementId' is not null or undefined
            assertParamExists('settlementControllerUpdateSettlementStatus', 'settlementId', settlementId)
            // verify required parameter 'updateSettlementStatusDto' is not null or undefined
            assertParamExists('settlementControllerUpdateSettlementStatus', 'updateSettlementStatusDto', updateSettlementStatusDto)
            const localVarPath = `/api/groups/{groupId}/settlements/{settlementId}/status`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"settlementId"}}`, encodeURIComponent(String(settlementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSettlementStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettlementsApi - functional programming interface
 */
export const SettlementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettlementsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create optimized settlements automatically
         * @summary Create optimized settlements automatically
         * @param {string} groupId 
         * @param {CreateOptimizedSettlementsDto} createOptimizedSettlementsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settlementControllerCreateOptimizedSettlements(groupId: string, createOptimizedSettlementsDto: CreateOptimizedSettlementsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SettlementResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settlementControllerCreateOptimizedSettlements(groupId, createOptimizedSettlementsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettlementsApi.settlementControllerCreateOptimizedSettlements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new settlement
         * @summary Create a new settlement
         * @param {string} groupId 
         * @param {CreateSettlementDto} createSettlementDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settlementControllerCreateSettlement(groupId: string, createSettlementDto: CreateSettlementDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettlementResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settlementControllerCreateSettlement(groupId, createSettlementDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettlementsApi.settlementControllerCreateSettlement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a settlement
         * @summary Delete a settlement
         * @param {string} groupId 
         * @param {string} settlementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settlementControllerDeleteSettlement(groupId: string, settlementId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settlementControllerDeleteSettlement(groupId, settlementId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettlementsApi.settlementControllerDeleteSettlement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Calculate balances for all group members
         * @summary Calculate balances for all group members
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settlementControllerGetBalances(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settlementControllerGetBalances(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettlementsApi.settlementControllerGetBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all settlements for a group
         * @summary Get all settlements for a group
         * @param {string} groupId 
         * @param {SettlementControllerGetGroupSettlementsStatusEnum} [status] Filter by status
         * @param {string} [fromDate] Filter from date
         * @param {string} [toDate] Filter to date
         * @param {string} [userId] Filter by user ID
         * @param {boolean} [isAutoGenerated] Filter by auto-generated settlements
         * @param {SettlementControllerGetGroupSettlementsSortByEnum} [sortBy] Sort by field
         * @param {SettlementControllerGetGroupSettlementsSortOrderEnum} [sortOrder] Sort order
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settlementControllerGetGroupSettlements(groupId: string, status?: SettlementControllerGetGroupSettlementsStatusEnum, fromDate?: string, toDate?: string, userId?: string, isAutoGenerated?: boolean, sortBy?: SettlementControllerGetGroupSettlementsSortByEnum, sortOrder?: SettlementControllerGetGroupSettlementsSortOrderEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettlementListResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settlementControllerGetGroupSettlements(groupId, status, fromDate, toDate, userId, isAutoGenerated, sortBy, sortOrder, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettlementsApi.settlementControllerGetGroupSettlements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get optimized settlement suggestions
         * @summary Get optimized settlement suggestions
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settlementControllerGetOptimizedSettlements(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SettlementOptimizationResultDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settlementControllerGetOptimizedSettlements(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettlementsApi.settlementControllerGetOptimizedSettlements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get settlement by ID
         * @summary Get settlement by ID
         * @param {string} groupId 
         * @param {string} settlementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settlementControllerGetSettlementById(groupId: string, settlementId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettlementResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settlementControllerGetSettlementById(groupId, settlementId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettlementsApi.settlementControllerGetSettlementById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get settlement statistics
         * @summary Get settlement statistics
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settlementControllerGetStatistics(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettlementStatisticsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settlementControllerGetStatistics(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettlementsApi.settlementControllerGetStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update settlement status
         * @summary Update settlement status
         * @param {string} groupId 
         * @param {string} settlementId 
         * @param {UpdateSettlementStatusDto} updateSettlementStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settlementControllerUpdateSettlementStatus(groupId: string, settlementId: string, updateSettlementStatusDto: UpdateSettlementStatusDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettlementResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settlementControllerUpdateSettlementStatus(groupId, settlementId, updateSettlementStatusDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettlementsApi.settlementControllerUpdateSettlementStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettlementsApi - factory interface
 */
export const SettlementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettlementsApiFp(configuration)
    return {
        /**
         * Create optimized settlements automatically
         * @summary Create optimized settlements automatically
         * @param {string} groupId 
         * @param {CreateOptimizedSettlementsDto} createOptimizedSettlementsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settlementControllerCreateOptimizedSettlements(groupId: string, createOptimizedSettlementsDto: CreateOptimizedSettlementsDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<SettlementResponseDto>> {
            return localVarFp.settlementControllerCreateOptimizedSettlements(groupId, createOptimizedSettlementsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new settlement
         * @summary Create a new settlement
         * @param {string} groupId 
         * @param {CreateSettlementDto} createSettlementDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settlementControllerCreateSettlement(groupId: string, createSettlementDto: CreateSettlementDto, options?: RawAxiosRequestConfig): AxiosPromise<SettlementResponseDto> {
            return localVarFp.settlementControllerCreateSettlement(groupId, createSettlementDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a settlement
         * @summary Delete a settlement
         * @param {string} groupId 
         * @param {string} settlementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settlementControllerDeleteSettlement(groupId: string, settlementId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.settlementControllerDeleteSettlement(groupId, settlementId, options).then((request) => request(axios, basePath));
        },
        /**
         * Calculate balances for all group members
         * @summary Calculate balances for all group members
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settlementControllerGetBalances(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<BalanceResponseDto>> {
            return localVarFp.settlementControllerGetBalances(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all settlements for a group
         * @summary Get all settlements for a group
         * @param {string} groupId 
         * @param {SettlementControllerGetGroupSettlementsStatusEnum} [status] Filter by status
         * @param {string} [fromDate] Filter from date
         * @param {string} [toDate] Filter to date
         * @param {string} [userId] Filter by user ID
         * @param {boolean} [isAutoGenerated] Filter by auto-generated settlements
         * @param {SettlementControllerGetGroupSettlementsSortByEnum} [sortBy] Sort by field
         * @param {SettlementControllerGetGroupSettlementsSortOrderEnum} [sortOrder] Sort order
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settlementControllerGetGroupSettlements(groupId: string, status?: SettlementControllerGetGroupSettlementsStatusEnum, fromDate?: string, toDate?: string, userId?: string, isAutoGenerated?: boolean, sortBy?: SettlementControllerGetGroupSettlementsSortByEnum, sortOrder?: SettlementControllerGetGroupSettlementsSortOrderEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<SettlementListResponseDto> {
            return localVarFp.settlementControllerGetGroupSettlements(groupId, status, fromDate, toDate, userId, isAutoGenerated, sortBy, sortOrder, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get optimized settlement suggestions
         * @summary Get optimized settlement suggestions
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settlementControllerGetOptimizedSettlements(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SettlementOptimizationResultDto>> {
            return localVarFp.settlementControllerGetOptimizedSettlements(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get settlement by ID
         * @summary Get settlement by ID
         * @param {string} groupId 
         * @param {string} settlementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settlementControllerGetSettlementById(groupId: string, settlementId: string, options?: RawAxiosRequestConfig): AxiosPromise<SettlementResponseDto> {
            return localVarFp.settlementControllerGetSettlementById(groupId, settlementId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get settlement statistics
         * @summary Get settlement statistics
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settlementControllerGetStatistics(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<SettlementStatisticsDto> {
            return localVarFp.settlementControllerGetStatistics(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update settlement status
         * @summary Update settlement status
         * @param {string} groupId 
         * @param {string} settlementId 
         * @param {UpdateSettlementStatusDto} updateSettlementStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settlementControllerUpdateSettlementStatus(groupId: string, settlementId: string, updateSettlementStatusDto: UpdateSettlementStatusDto, options?: RawAxiosRequestConfig): AxiosPromise<SettlementResponseDto> {
            return localVarFp.settlementControllerUpdateSettlementStatus(groupId, settlementId, updateSettlementStatusDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettlementsApi - object-oriented interface
 */
export class SettlementsApi extends BaseAPI {
    /**
     * Create optimized settlements automatically
     * @summary Create optimized settlements automatically
     * @param {string} groupId 
     * @param {CreateOptimizedSettlementsDto} createOptimizedSettlementsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public settlementControllerCreateOptimizedSettlements(groupId: string, createOptimizedSettlementsDto: CreateOptimizedSettlementsDto, options?: RawAxiosRequestConfig) {
        return SettlementsApiFp(this.configuration).settlementControllerCreateOptimizedSettlements(groupId, createOptimizedSettlementsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new settlement
     * @summary Create a new settlement
     * @param {string} groupId 
     * @param {CreateSettlementDto} createSettlementDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public settlementControllerCreateSettlement(groupId: string, createSettlementDto: CreateSettlementDto, options?: RawAxiosRequestConfig) {
        return SettlementsApiFp(this.configuration).settlementControllerCreateSettlement(groupId, createSettlementDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a settlement
     * @summary Delete a settlement
     * @param {string} groupId 
     * @param {string} settlementId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public settlementControllerDeleteSettlement(groupId: string, settlementId: string, options?: RawAxiosRequestConfig) {
        return SettlementsApiFp(this.configuration).settlementControllerDeleteSettlement(groupId, settlementId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calculate balances for all group members
     * @summary Calculate balances for all group members
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public settlementControllerGetBalances(groupId: string, options?: RawAxiosRequestConfig) {
        return SettlementsApiFp(this.configuration).settlementControllerGetBalances(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all settlements for a group
     * @summary Get all settlements for a group
     * @param {string} groupId 
     * @param {SettlementControllerGetGroupSettlementsStatusEnum} [status] Filter by status
     * @param {string} [fromDate] Filter from date
     * @param {string} [toDate] Filter to date
     * @param {string} [userId] Filter by user ID
     * @param {boolean} [isAutoGenerated] Filter by auto-generated settlements
     * @param {SettlementControllerGetGroupSettlementsSortByEnum} [sortBy] Sort by field
     * @param {SettlementControllerGetGroupSettlementsSortOrderEnum} [sortOrder] Sort order
     * @param {number} [page] Page number
     * @param {number} [limit] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public settlementControllerGetGroupSettlements(groupId: string, status?: SettlementControllerGetGroupSettlementsStatusEnum, fromDate?: string, toDate?: string, userId?: string, isAutoGenerated?: boolean, sortBy?: SettlementControllerGetGroupSettlementsSortByEnum, sortOrder?: SettlementControllerGetGroupSettlementsSortOrderEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return SettlementsApiFp(this.configuration).settlementControllerGetGroupSettlements(groupId, status, fromDate, toDate, userId, isAutoGenerated, sortBy, sortOrder, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get optimized settlement suggestions
     * @summary Get optimized settlement suggestions
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public settlementControllerGetOptimizedSettlements(groupId: string, options?: RawAxiosRequestConfig) {
        return SettlementsApiFp(this.configuration).settlementControllerGetOptimizedSettlements(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get settlement by ID
     * @summary Get settlement by ID
     * @param {string} groupId 
     * @param {string} settlementId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public settlementControllerGetSettlementById(groupId: string, settlementId: string, options?: RawAxiosRequestConfig) {
        return SettlementsApiFp(this.configuration).settlementControllerGetSettlementById(groupId, settlementId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get settlement statistics
     * @summary Get settlement statistics
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public settlementControllerGetStatistics(groupId: string, options?: RawAxiosRequestConfig) {
        return SettlementsApiFp(this.configuration).settlementControllerGetStatistics(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update settlement status
     * @summary Update settlement status
     * @param {string} groupId 
     * @param {string} settlementId 
     * @param {UpdateSettlementStatusDto} updateSettlementStatusDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public settlementControllerUpdateSettlementStatus(groupId: string, settlementId: string, updateSettlementStatusDto: UpdateSettlementStatusDto, options?: RawAxiosRequestConfig) {
        return SettlementsApiFp(this.configuration).settlementControllerUpdateSettlementStatus(groupId, settlementId, updateSettlementStatusDto, options).then((request) => request(this.axios, this.basePath));
    }
}

export const SettlementControllerGetGroupSettlementsStatusEnum = {
    Pending: 'pending',
    Completed: 'completed',
    Cancelled: 'cancelled'
} as const;
export type SettlementControllerGetGroupSettlementsStatusEnum = typeof SettlementControllerGetGroupSettlementsStatusEnum[keyof typeof SettlementControllerGetGroupSettlementsStatusEnum];
export const SettlementControllerGetGroupSettlementsSortByEnum = {
    Date: 'date',
    Amount: 'amount',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;
export type SettlementControllerGetGroupSettlementsSortByEnum = typeof SettlementControllerGetGroupSettlementsSortByEnum[keyof typeof SettlementControllerGetGroupSettlementsSortByEnum];
export const SettlementControllerGetGroupSettlementsSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type SettlementControllerGetGroupSettlementsSortOrderEnum = typeof SettlementControllerGetGroupSettlementsSortOrderEnum[keyof typeof SettlementControllerGetGroupSettlementsSortOrderEnum];


/**
 * UserApi - axios parameter creator
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change own password
         * @summary Change own password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerChangePassword: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate own account
         * @summary Deactivate own account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerDeactivateOwnAccount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/deactivate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete own account
         * @summary Delete own account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerDeleteAccount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user profile
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User login
         * @summary User login
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerLogin: async (loginDto: LoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('userControllerLogin', 'loginDto', loginDto)
            const localVarPath = `/api/users/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new user
         * @summary Register a new user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRegister: async (createUserDto: CreateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('userControllerRegister', 'createUserDto', createUserDto)
            const localVarPath = `/api/users/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update own profile
         * @summary Update own profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Change own password
         * @summary Change own password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerChangePassword(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerChangePassword(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerChangePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deactivate own account
         * @summary Deactivate own account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerDeactivateOwnAccount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerDeactivateOwnAccount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerDeactivateOwnAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete own account
         * @summary Delete own account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerDeleteAccount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerDeleteAccount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerDeleteAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current user profile
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerGetProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User login
         * @summary User login
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerLogin(loginDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a new user
         * @summary Register a new user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerRegister(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerRegister(createUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update own profile
         * @summary Update own profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdateProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdateProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerUpdateProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Change own password
         * @summary Change own password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerChangePassword(options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseDto> {
            return localVarFp.userControllerChangePassword(options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivate own account
         * @summary Deactivate own account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerDeactivateOwnAccount(options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseDto> {
            return localVarFp.userControllerDeactivateOwnAccount(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete own account
         * @summary Delete own account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerDeleteAccount(options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseDto> {
            return localVarFp.userControllerDeleteAccount(options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user profile
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetProfile(options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.userControllerGetProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * User login
         * @summary User login
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponseDto> {
            return localVarFp.userControllerLogin(loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new user
         * @summary Register a new user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRegister(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.userControllerRegister(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update own profile
         * @summary Update own profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateProfile(options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.userControllerUpdateProfile(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * Change own password
     * @summary Change own password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerChangePassword(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerChangePassword(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivate own account
     * @summary Deactivate own account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerDeactivateOwnAccount(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerDeactivateOwnAccount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete own account
     * @summary Delete own account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerDeleteAccount(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerDeleteAccount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user profile
     * @summary Get current user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerGetProfile(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerGetProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User login
     * @summary User login
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerLogin(loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a new user
     * @summary Register a new user
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerRegister(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerRegister(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update own profile
     * @summary Update own profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerUpdateProfile(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerUpdateProfile(options).then((request) => request(this.axios, this.basePath));
    }
}



